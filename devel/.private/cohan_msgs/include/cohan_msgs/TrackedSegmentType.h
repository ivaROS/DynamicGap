// Generated by gencpp from file cohan_msgs/TrackedSegmentType.msg
// DO NOT EDIT!


#ifndef COHAN_MSGS_MESSAGE_TRACKEDSEGMENTTYPE_H
#define COHAN_MSGS_MESSAGE_TRACKEDSEGMENTTYPE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace cohan_msgs
{
template <class ContainerAllocator>
struct TrackedSegmentType_
{
  typedef TrackedSegmentType_<ContainerAllocator> Type;

  TrackedSegmentType_()
    {
    }
  TrackedSegmentType_(const ContainerAllocator& _alloc)
    {
  (void)_alloc;
    }





// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(HEAD)
  #undef HEAD
#endif
#if defined(_WIN32) && defined(TORSO)
  #undef TORSO
#endif
#if defined(_WIN32) && defined(RIGHT_SHOULDER)
  #undef RIGHT_SHOULDER
#endif
#if defined(_WIN32) && defined(RIGHT_ELBOW)
  #undef RIGHT_ELBOW
#endif
#if defined(_WIN32) && defined(RIGHT_WRIST)
  #undef RIGHT_WRIST
#endif
#if defined(_WIN32) && defined(RIGHT_HIP)
  #undef RIGHT_HIP
#endif
#if defined(_WIN32) && defined(RIGHT_KNEE)
  #undef RIGHT_KNEE
#endif
#if defined(_WIN32) && defined(RIGHT_ANKLE)
  #undef RIGHT_ANKLE
#endif
#if defined(_WIN32) && defined(LEFT_SHOULDER)
  #undef LEFT_SHOULDER
#endif
#if defined(_WIN32) && defined(LEFT_ELBOW)
  #undef LEFT_ELBOW
#endif
#if defined(_WIN32) && defined(LEFT_WRIST)
  #undef LEFT_WRIST
#endif
#if defined(_WIN32) && defined(LEFT_HIP)
  #undef LEFT_HIP
#endif
#if defined(_WIN32) && defined(LEFT_KNEE)
  #undef LEFT_KNEE
#endif
#if defined(_WIN32) && defined(LEFT_ANKLE)
  #undef LEFT_ANKLE
#endif

  enum {
    HEAD = 0,
    TORSO = 1,
    RIGHT_SHOULDER = 2,
    RIGHT_ELBOW = 3,
    RIGHT_WRIST = 4,
    RIGHT_HIP = 5,
    RIGHT_KNEE = 6,
    RIGHT_ANKLE = 7,
    LEFT_SHOULDER = 8,
    LEFT_ELBOW = 9,
    LEFT_WRIST = 10,
    LEFT_HIP = 11,
    LEFT_KNEE = 12,
    LEFT_ANKLE = 13,
  };


  typedef boost::shared_ptr< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> const> ConstPtr;

}; // struct TrackedSegmentType_

typedef ::cohan_msgs::TrackedSegmentType_<std::allocator<void> > TrackedSegmentType;

typedef boost::shared_ptr< ::cohan_msgs::TrackedSegmentType > TrackedSegmentTypePtr;
typedef boost::shared_ptr< ::cohan_msgs::TrackedSegmentType const> TrackedSegmentTypeConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >::stream(s, "", v);
return s;
}


} // namespace cohan_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >
{
  static const char* value()
  {
    return "68d3b979cac8949295c8f9c93334f520";
  }

  static const char* value(const ::cohan_msgs::TrackedSegmentType_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x68d3b979cac89492ULL;
  static const uint64_t static_value2 = 0x95c8f9c93334f520ULL;
};

template<class ContainerAllocator>
struct DataType< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >
{
  static const char* value()
  {
    return "cohan_msgs/TrackedSegmentType";
  }

  static const char* value(const ::cohan_msgs::TrackedSegmentType_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# constants, adapted from human avatar in morse simulator\n"
"int8    HEAD=0\n"
"int8    TORSO=1\n"
"int8    RIGHT_SHOULDER=2\n"
"int8    RIGHT_ELBOW=3\n"
"int8    RIGHT_WRIST=4\n"
"int8    RIGHT_HIP=5\n"
"int8    RIGHT_KNEE=6\n"
"int8    RIGHT_ANKLE=7\n"
"int8    LEFT_SHOULDER=8\n"
"int8    LEFT_ELBOW=9\n"
"int8    LEFT_WRIST=10\n"
"int8    LEFT_HIP=11\n"
"int8    LEFT_KNEE=12\n"
"int8    LEFT_ANKLE=13\n"
;
  }

  static const char* value(const ::cohan_msgs::TrackedSegmentType_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream&, T)
    {}

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TrackedSegmentType_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::cohan_msgs::TrackedSegmentType_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream&, const std::string&, const ::cohan_msgs::TrackedSegmentType_<ContainerAllocator>&)
  {}
};

} // namespace message_operations
} // namespace ros

#endif // COHAN_MSGS_MESSAGE_TRACKEDSEGMENTTYPE_H
