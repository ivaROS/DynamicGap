# Autogenerated param section. Do not hand edit.
param {
group.0 {
name=Dynamically Reconfigurable Parameters
desc=See the [[dynamic_reconfigure]] package for details on dynamically reconfigurable parameters.
0.name= ~numerical_filtering
0.default= False
0.type= bool
0.desc=Numerical Filtering yes/no 
1.name= ~damping_method
1.default= 4
1.type= int
1.desc=The damping method to use. Possible values are: NO_DAMPING (0): No damping means a damping factor of 0.0., CONSTANT (1): Constant damping factor given by parameter damping_factor., MANIPULABILITY (2): Damping factor calculation based on the manipulability measure., LEAST_SINGULAR_VALUE (3): Damping factor calculation based on the least singular value, SIGMOID (4): Damping factor calculation based on sigmoid functions
2.name= ~damping_factor
2.default= 0.01
2.type= double
2.desc=The constant damping_factor (used in CONSTANT) Range: 0.0 to 1.0
3.name= ~lambda_max
3.default= 0.001
3.type= double
3.desc=Value for maximum damping_factor (used in MANIPULABILITY/LSV/SIGMOID) Range: 0.0 to 10.0
4.name= ~w_threshold
4.default= 0.001
4.type= double
4.desc=Value for manipulability threshold (used in MANIPULABILITY/SIGMOID) Range: 0.0 to 0.1
5.name= ~beta
5.default= 0.005
5.type= double
5.desc=Beta for Low Isotropic Damping Range: 0.0 to 1.0
6.name= ~slope_damping
6.default= 0.05
6.type= double
6.desc=Value for the activation gradient (used in SIGMOID) Range: 0.001 to 0.1
7.name= ~eps_damping
7.default= 0.003
7.type= double
7.desc=Value for least singular value damping Range: 0.0 to 1.0
8.name= ~eps_truncation
8.default= 0.001
8.type= double
8.desc=Value for singular value threshold (used for truncation: sing. value < eps) Range: 0.0 to 1.0
9.name= ~solver
9.default= 1
9.type= int
9.desc=The solver to use (edited via an enum) Possible values are: DEFAULT_SOLVER (0): No constraints active, WLN (1): Weighted-least-norm base, with identity as weighting matrix (equal to None), GPM (2): Gradient-projection-method, STACK_OF_TASKS (3): Task Priority Strategy for all with dynamic resadjust of GPM and task ..., TASK_2ND_PRIO (4): Task Priority Strategy for obstacle avoidance ..., UNIFIED_JLA_SA (5): Inv Kinematics solver based on unified weighted least norm and sigmoid weighting functions
10.name= ~priority
10.default= 500
10.type= int
10.desc=Priority for the main end-effector task (important for task processing; 0 = highest prio) Range: 0 to 1000
11.name= ~k_H
11.default= 1.0
11.type= double
11.desc=Self-motion factor for GPM (for both JLA and CA; multiplies the homogeneous solution).  Range: -1000.0 to 1000.0
12.name= ~constraint_jla
12.default= 1
12.type= int
12.desc=The JLA constraint to use (edited via an enum) Possible values are: JLA_OFF (0): JLA inactive, JLA (1): JLA active, JLA_MID (2): Special JLA: Keep joint pos in the middle of the limited range., JLA_INEQ (3): Inequality constraint for JLA.
13.name= ~priority_jla
13.default= 50
13.type= int
13.desc=Priority for the joint limit avoidance constraint (important for task processing; 0 = highest prio) Range: 0 to 1000
14.name= ~k_H_jla
14.default= -1.0
14.type= double
14.desc=Self-motion factor for GPM. Special weighting for JLA constraint Range: -1000.0 to 1000.0
15.name= ~activation_threshold_jla
15.default= 10.0
15.type= double
15.desc=In [%]. Tolerance from min and max joint positition limit. Range: 0.0 to 100.0
16.name= ~activation_buffer_jla
16.default= 300.0
16.type= double
16.desc=In [%]. For smooth transition an additional buffer to activation threshold can be given. Smoothing is started prior to activation threshold. (0 % = no smoothing) Range: 0.0 to 500.0
17.name= ~critical_threshold_jla
17.default= 5.0
17.type= double
17.desc=In [%]. Tolerance when critical region becomes active. JLA becomes task. Should be less than activation threshold (best experienced: 1/2 of activation threshold). Range: 0.0 to 100.0
18.name= ~damping_jla
18.default= 1e-06
18.type= double
18.desc=Const. damping factor for the inv. of the JLA task jacobian Range: 0.0 to 1.0
19.name= ~constraint_ca
19.default= 0
19.type= int
19.desc=The CA constraint to use (edited via an enum) Possible values are: CA_OFF (0): CA inactive, CA (1): Collision avoidance active!
20.name= ~priority_ca
20.default= 100
20.type= int
20.desc=Priority for the collision avoidance constraint (important for task processing; 0 = highest prio). Range: 0 to 1000
21.name= ~k_H_ca
21.default= -20.0
21.type= double
21.desc=Self-motion factor for GPM. Special weighting for CA constraint Range: -1000.0 to 1000.0
22.name= ~activation_threshold_ca
22.default= 0.1
22.type= double
22.desc=The distance the constraint shall get active in [m]. Range: 0.0 to 1.0
23.name= ~activation_buffer_ca
23.default= 50.0
23.type= double
23.desc=In [%]. For smooth transition an additional buffer to activation threshold can be given. Smoothing is started prior to activation threshold. (0 % = no smoothing) Range: 0.0 to 100.0
24.name= ~critical_threshold_ca
24.default= 0.025
24.type= double
24.desc=Tolerance when critical region becomes active. CA becomes task. Should be less than activation threshold (best experienced: 1/4 of activation threshold). Range: 0.0 to 1.0
25.name= ~damping_ca
25.default= 1e-06
25.type= double
25.desc=Const. damping factor for the inv. of the CA task jacobian Range: 0.0 to 1.0
26.name= ~sigma
26.default= 0.01
26.type= double
26.desc=Sigma Range: 0.01 to 1.0
27.name= ~sigma_speed
27.default= 5.0
27.type= double
27.desc=Sigma Speed Range: 0.01 to 10.0
28.name= ~delta_pos
28.default= 0.5
28.type= double
28.desc=Delta Pos Range: 0.001 to 1.0
29.name= ~delta_speed
29.default= 1.0
29.type= double
29.desc=Delta Speed Range: 0.001 to 10.0
30.name= ~keep_direction
30.default= True
30.type= bool
30.desc=With keep_direction the whole joint positions and velocities vector is affected by a scaling factor. Else only individual components of the vectors are affected -> direction will be changed. 
31.name= ~enforce_input_limits
31.default= True
31.type= bool
31.desc=If 'True', enforce Cartesian velocity limits on input twist 
32.name= ~enforce_pos_limits
32.default= True
32.type= bool
32.desc=If 'True', enforce joint position limits in TwistController, else let RobotHW handle the limits 
33.name= ~enforce_vel_limits
33.default= True
33.type= bool
33.desc=If 'True', enforce joint velocity limits in TwistController, else let RobotHW handle the limits 
34.name= ~enforce_acc_limits
34.default= False
34.type= bool
34.desc=If 'True', enforce joint acceleration limits in TwistController, else let RobotHW handle the limits 
35.name= ~limits_tolerance
35.default= 30.0
35.type= double
35.desc=Tolerance around joint position limits where velocities are normalized [degrees]. Must not be zero else DIV/0! Range: 0.0 to 90.0
36.name= ~max_lin_twist
36.default= 0.5
36.type= double
36.desc=Maximum input linear velocity, twist command for the inverse kinematics solver in [m/s]. Range: 0.0 to 5.0
37.name= ~max_rot_twist
37.default= 0.5
37.type= double
37.desc=Maximum input rotational velocity, twist command for the inverse kinematics solver in [rad/s]. Range: 0.0 to 5.0
38.name= ~max_vel_lin_base
38.default= 0.5
38.type= double
38.desc=Maximum linear velocity to be commanded to the base in [m/s]. Range: 0.0 to 1.5
39.name= ~max_vel_rot_base
39.default= 0.5
39.type= double
39.desc=Maximum rotational velocity to be commanded to the base in [rad/s]. Range: 0.0 to 1.5
40.name= ~kinematic_extension
40.default= 0
40.type= int
40.desc=Consider additional DoF Possible values are: NO_EXTENSION (0): No additional DoF considered, BASE_COMPENSATION (1): Compensate base motion, BASE_ACTIVE (2): Consider additional DoF of a mobile base (2d), COB_TORSO (3): KinematicExtension for COB_TORSO (any DoF), LOOKAT (4): Consider additional DoF of a virtual Lookat component
41.name= ~extension_ratio
41.default= 0.01
41.type= double
41.desc=Value for ratio between chain and extension Range: 0.0 to 1.0
}
}
# End of autogenerated section. You may edit below.
