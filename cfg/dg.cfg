#!/usr/bin/env python

PACKAGE = "dynamic_gap"
from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, int_t, double_t, bool_t

gen = ParameterGenerator()

# structure: gen.add(param_name, param_type, level, description, default, min, max)


# Default will be overridden by yaml (need to check this)

# GAP VISUALIZATION
gen.add("min_resoln", int_t, 0, "Min Resoln idx of Gaps", 2, 1, 512)
gen.add("fig_gen", bool_t, 0, "Visualize for Figure", True)
gen.add("viz_jitter", double_t, 0, "Displacement for visualization about overlapping location", 0.05, 0, 1)
gen.add("debug_viz", bool_t, 0, "Toggle for all visualization", True)

# ROBOT 
gen.add("r_inscr", double_t, 0, "Inscribed Radius", 0.2, 0, 10)
gen.add("num_obsts", int_t, 0, "Number of dynamic agents in run", 0, 0, 100)
gen.add("max_range", double_t, 0, "maximum sensing range for robot", 4.99, 0.0, 100.0)

# PLANNING INFORMATION
gen.add("projection_inflated", bool_t, 0, "Projection Operator using inflated", False)
gen.add("planning_inflated", bool_t, 0, "Planning using inflated", False)
gen.add("far_feasible", bool_t, 0, "Pick The Farthest Feasible Local Waypoint", True)
gen.add("holonomic", bool_t, 0, "Boolean for if robot is holonomic or non-holonomic", False)
gen.add("full_fov", bool_t, 0, "Boolean for if robot has full field of view (360 deg)", False)
gen.add("projection_operator", bool_t, 0, "Boolean for if Projection Operator is enabled or disabled", False)
gen.add("num_feasi_check", int_t, 0, "Poses for feasibility check", 20, 0 , 50)
gen.add("halt_size", int_t, 0, "Initialization size for velocity command log", 5, 0, 50)
gen.add("egocircle_prop_cheat", bool_t, 0, "Whether or not to propagate egocircle forward in time using ground truth agent information ", False)

# MANUAL CONTROL
gen.add("man_ctrl", bool_t, 0, "Manual control", True)
gen.add("man_x", double_t, 0, "Manual control", 0, 0, 0.5)
gen.add("man_y", double_t, 0, "Manual control", 0, -0.5, 0.5)
gen.add("man_theta", double_t, 0, "Manual control", 0, -1.5, 1.5)

# GLOBAL GOAL AND WAYPOINTS
gen.add("goal_tolerance", double_t, 0, "Tolerance for goal checking", 0.2, 0, 1)
gen.add("waypoint_tolerance", double_t, 0, "Tolerance for goal checking", 0.1, 0, 1)

# DEBUG
gen.add("raw_gaps_debug_log", bool_t, 0, "debugging statements for raw gaps (detection, association, model updates)", False)
gen.add("static_scan_separation_debug_log", bool_t, 0, "debugging statements for static scan separation", False)
gen.add("simplified_gaps_debug_log", bool_t, 0, "debugging statements for raw gaps (detection, association, model updates)", True)
gen.add("feasibility_debug_log", bool_t, 0, "debugging statements for gap feasibility", False)
gen.add("manipulation_debug_log", bool_t, 0, "debugging statements for gap manipulation", False)
gen.add("traj_debug_log", bool_t, 0, "debugging statements for trajectory generation and scoring", False)
gen.add("control_debug_log", bool_t, 0, "debugging statements for control", False)

# GAP MODELS    
gen.add("R_xx", double_t, 0, "Noise matrix value for x/x", 0.01, 0.0, 10.0)
gen.add("R_yy", double_t, 0, "Noise matrix value for y/y", 0.01, 0.0, 10.0)
gen.add("Q_VxVx", double_t, 0, "Covariance matrix value for v_x/v_x", 0.5, 0.0, 10.0)
gen.add("Q_VyVy", double_t, 0, "Covariance matrix value for v_y/v_y", 0.5, 0.0, 10.0)

# GAP ASSOCIATION
gen.add("assoc_thresh", double_t, 0, "Distance threshold for gap association", 0.25, 0.0, 5.0)

# GAP MANIPULATION
gen.add("epsilon1", double_t, 0, "Epsilon1 value in radial gap conversion", 0.18, 0, 1)
gen.add("epsilon2", double_t, 0, "Epsilon2 value in radial gap conversion", 0.18, 0, 1)
gen.add("rot_ratio", double_t, 0, "Small offset to make local waypoint absolutely visible", 1.5, 0, 10)
gen.add("reduction_threshold", double_t, 0, "threshold value for gap reduction", 3.1415926, 0, 6.283)
gen.add("reduction_target", double_t, 0, "target value for gap reduction", 3.1415926, 0, 6.283)
gen.add("max_idx_diff", int_t, 0, "Max dist for merging gaps", 256, 1 , 511)
gen.add("radial_extend", bool_t, 0, "Toggle Radial Extension", True)
gen.add("radial_convert", bool_t, 0, "Radial Gap Conversion", True)

# TRAJECTORY
gen.add("synthesized_frame",    bool_t,   0, "True to synthesize trajectory in the same frame as sensor", True)
gen.add("scale",                double_t, 0, "Scaling coefficient used in trajectory generation", 1., 0.01, 50)
gen.add("integrate_maxt",       double_t, 0, "maximum time for integrator", 5.0, 0.0, 1000)
gen.add("integrate_stept",      double_t, 0, "step time for integrator", 0.50, 0.000001, 100)
gen.add("max_pose_pen_dist", double_t, 0, "Distance within which a penalty is given to a pose during trajectory scoring ", 0.5, 0, 100)
gen.add("inf_ratio", double_t, 0, "Ratio of inscribed r for infinity range", 1.21, 0, 4)
gen.add("terminal_weight", double_t, 0, "Weight for Terminal Cost", 0, 10, 100)
gen.add("waypoint_ratio", double_t, 0, "Ratio of robot radius to push inward for placing a waypoint in a gap", 1.5, 0, 10)
gen.add("num_curve_points", int_t, 0, "number of pts used to discretize left/right bezier curves", 20, 1, 100)
gen.add("num_qB_points", int_t, 0, "number of pts used to discretize radial extension", 6, 1, 100)

# CONTROL 

# PROJECTION OPERATOR

gen.add("ctrl_ahead_pose", int_t, 0, "Number of ahead poses to skip for NI ctrl", 1, 0, 50)

gen.add("k_fb_x", double_t, 0, "Feedback gain for linear velocity in x direction", 0.5, 0.01 , 100)
gen.add("k_fb_y", double_t, 0, "Feedback gain for linear velocity in y direction", 0.5, 0.01 , 100)
gen.add("k_fb_theta", double_t, 0, "Feedback gain for angular velocity in theta direction", 0.5, 0.01 , 100)
gen.add("k_po_x", double_t, 0, "Gain for projection operator", 1., 0.01 , 100)
gen.add("k_po_theta", double_t, 0, "Gain for projection operator", 1., 0.01 , 100)
gen.add("k_CBF", double_t, 0, "Gain for CBF-based safe command velocity", 1.0, 0.01, 100)
gen.add("vx_absmax", double_t, 0, "absolute max vel", 0.5, 0, 2)
gen.add("vy_absmax", double_t, 0, "absolute max vel", 0.5, 0, 2)
gen.add("vang_absmax", double_t, 0, "absolute max angular vel", 1.5, 0.0, 10.0)
gen.add("ax_absmax", double_t, 0, "absolute max acc", 3.0, 0, 10.0)
gen.add("ay_absmax", double_t, 0, "absolute max acc", 3.0, 0, 10.0)
gen.add("aang_absmax", double_t, 0, "absolute max angular acc", 3.0, 0.0, 10.0)

gen.add("line", bool_t, 0, "Line", False)

# for cbf param, smaller value is more strict
gen.add("cbf_param", double_t, 0, "parameter used in CBF constraint", 0.1, 0.0, 100)

gen.add("r_min", double_t, 0, "r min", 0.35, 0.01, 5) # when PO passes through 1
gen.add("r_norm", double_t, 0, "r norm", 1.0, 0.01, 5) # when PO passes through 0
gen.add("r_norm_offset", double_t, 0, "r norm offset for r max", 0.5, 0.01, 5)
exit(gen.generate(PACKAGE, PACKAGE, "dg"))
